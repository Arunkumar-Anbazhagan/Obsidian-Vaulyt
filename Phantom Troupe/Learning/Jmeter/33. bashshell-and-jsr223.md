---
# yaml-language-server: $schema=schemas\page.schema.json
Object type:
    - Page
Backlinks:
    - Jmeter
Creation date: "2025-12-30T09:17:22Z"
Created by:
    - Arunkumar Anbazhagan
id: bafyreibplqp365unet6m7bdv4lniy2hguk7ns44pm563npy44ctk2yhrnq
---
# Bashshell and JSR223   
![image](files\image.png)    
## What JSR223 is   
- JSR223 is a scripting API for JVM languages that JMeter uses to run scripts (Groovy, etc.) and is useful for debugging and extending JMeter tests.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
- In practice, the article recommends JSR223 with **Groovy**, since Groovy scripts can be compiled into native Java bytecode, approaching Java-level execution speed.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
   
## When to use which engine   
- **Beanshell**:   
    - Acceptable for “once-only” or low-frequency work, such as reading config files in a single-threaded setUp Thread Group, or quick-and-dirty scripting when performance is not critical.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
    - Not recommended for heavy load or per-request logic because it is slower and more resource-intensive than the alternatives.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
- **JSR223 + Groovy**:   
    - Recommended as the general-purpose scripting option for JMeter when you need flexibility and good performance.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
    - Works well for extensive load testing scenarios like building large HTTP requests from calculated data, provided compilation caching is enabled.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
- **Java Request Sampler**:   
    - Implemented by writing a class that implements `JavaSamplerClient`, packaging it as a JAR, and putting it in JMeter’s `lib/ext` (or uploading to BlazeMeter with the script).[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
    - Best choice when you need maximum performance and are comfortable coding and maintaining Java classes for your test logic.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
   
## JSR223 (Groovy) best practices   
- Use external `.groovy` files where possible instead of large inline scripts in the sampler.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
- Do not use `${VAR}` inside Groovy; instead use `vars.get("VAR")` or pass data via the JSR223 “Parameters” section, and apply the same rule for JMeter Functions.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
- Keep “Cache compiled script” **enabled**, since disabling it removes the compilation benefit and hurts performance.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
   
## Java Request Sampler setup details   
- At minimum you override `runTest()` in your `JavaSamplerClient` implementation; for parameterization, you add logic to read inputs and decide whether the sampler passed or failed.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
- The compiled class/JAR goes into `lib/ext` so JMeter auto-loads it; on BlazeMeter, you upload the JAR along with your JMX and other extensions so the engine can use it.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
- The article links to example encryption/decryption implementations in GitHub and JMX samples that demonstrate how to wire these Java samplers into tests.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
   
## Performance numbers and conclusion   
- Reported metrics table:[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
    - Beanshell: 46,294 samplers, 771 hits/second, 99% line 6 ms.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
    - JSR223: 51,946 samplers, 865 hits/second, 99% line 5 ms.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
    - Java: 64,305 samplers, 1,071 hits/second, 99% line 3 ms.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
- Interpretation:[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
    - Beanshell: OK for one-off tasks, not ideal for heavy scripting.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
    - JSR223 (Groovy with caching): good balance of speed and convenience for most scripting needs.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
    - Java Request Sampler: “winner” for raw performance and scalability when you are willing to invest in Java code.[https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter](https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-jmeter)   
